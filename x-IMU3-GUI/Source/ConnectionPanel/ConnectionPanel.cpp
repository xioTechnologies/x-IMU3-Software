#include "ApplicationSettings.h"
#include "ConnectionPanel.h"
#include "ConnectionPanelContainer.h"
#include "Windows/DeviceSettingsWindow.h"
// Start of code block #0 generated by x-IMU3-GUI/Source/Windows/Graphs/generate_graph_windows.py
#include "Windows/Graphs/GyroscopeGraphWindow.h"
#include "Windows/Graphs/AccelerometerGraphWindow.h"
#include "Windows/Graphs/MagnetometerGraphWindow.h"
#include "Windows/Graphs/EulerAnglesGraphWindow.h"
#include "Windows/Graphs/LinearAccelerationGraphWindow.h"
#include "Windows/Graphs/EarthAccelerationGraphWindow.h"
#include "Windows/Graphs/HighGAccelerometerGraphWindow.h"
#include "Windows/Graphs/TemperatureGraphWindow.h"
#include "Windows/Graphs/BatteryPercentageGraphWindow.h"
#include "Windows/Graphs/BatteryVoltageGraphWindow.h"
#include "Windows/Graphs/RssiPercentageGraphWindow.h"
#include "Windows/Graphs/RssiPowerGraphWindow.h"
#include "Windows/Graphs/SerialAccessoryCsvsGraphWindow.h"
#include "Windows/Graphs/ReceivedMessageRateGraphWindow.h"
#include "Windows/Graphs/ReceivedDataRateGraphWindow.h"
// End of code block #0 generated by x-IMU3-GUI/Source/Windows/Graphs/generate_graph_windows.py
#include "Windows/SerialAccessoryTerminalWindow.h"
#include "Windows/ThreeDViewWindow.h"
#include "Windows/WindowIds.h"

ConnectionPanel::ConnectionPanel(const juce::ValueTree& windowLayout_,
                                 std::shared_ptr<ximu3::Connection> connection_,
                                 OpenGLRenderer& openGLRenderer_,
                                 ConnectionPanelContainer& connectionPanelContainer_,
                                 const juce::Colour& tag_,
                                 const bool keepOpenEnabled_)
    : windowLayout(windowLayout_),
      connection(connection_),
      openGLRenderer(openGLRenderer_),
      connectionPanelContainer(connectionPanelContainer_),
      tag(tag_),
      keepOpenEnabled(keepOpenEnabled_)
{
    addAndMakeVisible(header);
    addAndMakeVisible(footer);
    addChildComponent(disabledOverlay);

    connect();
}

ConnectionPanel::~ConnectionPanel()
{
    connection->close();

    *destroyed = true;
}

void ConnectionPanel::resized()
{
    auto bounds = getLocalBounds();
    disabledOverlay.setBounds(bounds);

    header.setBounds(bounds.removeFromTop(headerHeight + UILayout::panelMargin));
    footer.setBounds(bounds.removeFromBottom(footerHeight + UILayout::panelMargin));

    if (windowContainer)
    {
        bounds.removeFromTop(UILayout::panelMargin);
        windowContainer->setBounds(bounds);
    }
}

std::shared_ptr<ximu3::Connection> ConnectionPanel::getConnection()
{
    return connection;
}

void ConnectionPanel::sendCommands(const std::vector<CommandMessage>& commands, SafePointer<juce::Component> callbackOwner, std::function<void(const std::vector<CommandMessage>& responses)> callback)
{
    connection->sendCommandsAsync({ commands.begin(), commands.end() }, ApplicationSettings::getSingleton().commands.retries, ApplicationSettings::getSingleton().commands.timeout, [&, callbackOwner, callback](auto responses)
    {
        juce::MessageManager::callAsync([&, callbackOwner, callback, responses]
        {
            header.updateHeading({ responses.begin(), responses.end() });

            if (callbackOwner != nullptr && callback != nullptr)
            {
                callback({ responses.begin(), responses.end() });
            }
        });
    });
}

const juce::Colour& ConnectionPanel::getTag() const
{
    return tag;
}

std::shared_ptr<Window> ConnectionPanel::getOrCreateWindow(const juce::ValueTree& windowTree)
{
    const auto type = windowTree.getType();
    auto& window = windows[type];
    if (window != nullptr)
    {
        return window;
    }
    if (type == WindowIds::DeviceSettings)
    {
        return window = std::make_shared<DeviceSettingsWindow>(windowLayout, type, *this);
    }
    if (type == WindowIds::ThreeDView)
    {
        return window = std::make_shared<ThreeDViewWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::SerialAccessoryTerminal)
    {
        return window = std::make_shared<SerialAccessoryTerminalWindow>(windowLayout, type, *this);
    }
    // Start of code block #1 generated by x-IMU3-GUI/Source/Windows/Graphs/generate_graph_windows.py
    if (type == WindowIds::Gyroscope)
    {
        return window = std::make_shared<GyroscopeGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::Accelerometer)
    {
        return window = std::make_shared<AccelerometerGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::Magnetometer)
    {
        return window = std::make_shared<MagnetometerGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::EulerAngles)
    {
        return window = std::make_shared<EulerAnglesGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::LinearAcceleration)
    {
        return window = std::make_shared<LinearAccelerationGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::EarthAcceleration)
    {
        return window = std::make_shared<EarthAccelerationGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::HighGAccelerometer)
    {
        return window = std::make_shared<HighGAccelerometerGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::Temperature)
    {
        return window = std::make_shared<TemperatureGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::BatteryPercentage)
    {
        return window = std::make_shared<BatteryPercentageGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::BatteryVoltage)
    {
        return window = std::make_shared<BatteryVoltageGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::RssiPercentage)
    {
        return window = std::make_shared<RssiPercentageGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::RssiPower)
    {
        return window = std::make_shared<RssiPowerGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::SerialAccessoryCsvs)
    {
        return window = std::make_shared<SerialAccessoryCsvsGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::ReceivedMessageRate)
    {
        return window = std::make_shared<ReceivedMessageRateGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    if (type == WindowIds::ReceivedDataRate)
    {
        return window = std::make_shared<ReceivedDataRateGraphWindow>(windowLayout, type, *this, openGLRenderer);
    }
    // End of code block #1 generated by x-IMU3-GUI/Source/Windows/Graphs/generate_graph_windows.py

    jassertfalse; // type not in WindowIds
    return window = std::make_shared<Window>(windowLayout, type, *this, "");
}

void ConnectionPanel::cleanupWindows()
{
    triggerAsyncUpdate();
}

juce::String ConnectionPanel::getHeading() const
{
    return header.getHeading();
}

juce::String ConnectionPanel::getDescriptor() const
{
    return header.getDescriptor();
}

ConnectionPanelContainer& ConnectionPanel::getConnectionPanelContainer()
{
    return connectionPanelContainer;
}

void ConnectionPanel::setOverlayVisible(const bool visible)
{
    disabledOverlay.setVisible(visible);
}

void ConnectionPanel::connect()
{
    header.updateHeading("Connecting...");
    header.showRetry({});

    const juce::WeakReference weakReference(this);

    if (keepOpenEnabled)
    {
        keepOpen = std::make_unique<ximu3::KeepOpen>(
            *connection, [ &, weakReference](ximu3::XIMU3_ConnectionStatus status)
            {
                juce::MessageManager::callAsync([&, weakReference, status]
                {
                    if (weakReference == nullptr)
                    {
                        return;
                    }

                    switch (status)
                    {
                        case ximu3::XIMU3_ConnectionStatusConnected:
                            connected();
                            break;

                        case ximu3::XIMU3_ConnectionStatusReconnecting:
                            recursivePing.reset();
                            header.updateHeading("Reconnecting...");
                            break;
                    }
                });
            });
    }
    else
    {
        connection->openAsync([&, weakReference](auto result)
        {
            juce::MessageManager::callAsync([&, weakReference, result]
            {
                if (weakReference == nullptr)
                {
                    return;
                }

                if (result != ximu3::XIMU3_ResultOk)
                {
                    header.updateHeading("Connection Failed");
                    header.showRetry([&]
                    {
                        connect();
                    });
                    return;
                }

                connected();
            });
        });
    }
}

void ConnectionPanel::connected()
{
    for (auto& window : windows)
    {
        window.second->reconnected();
    }

    if (windowContainer == nullptr)
    {
        windowContainer = std::make_unique<WindowContainer>(*this, windowLayout);
        addAndMakeVisible(*windowContainer);
        resized();
    }

    header.showLocate();

    recursivePing = std::make_unique<RecursivePing>(connection, [&](const juce::String& deviceName, const juce::String& serialNumber)
    {
        header.updateHeading(deviceName, serialNumber);
    });
}

void ConnectionPanel::handleAsyncUpdate()
{
    for (auto& window : windows)
    {
        // Destroy if the use_count is 1, since it means no one is pointing to it except us
        if (window.second.use_count() == 1)
        {
            window.second.reset();
        }
    }
}

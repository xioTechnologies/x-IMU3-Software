// This file was generated by x-IMU3-GUI/Source/Windows/Graphs/generate_graph_windows.py

#include "ConnectionPanel/ConnectionPanel.h"
#include "Convert.h"
#include "EulerAnglesGraphWindow.h"

EulerAnglesGraphWindow::EulerAnglesGraphWindow(const juce::ValueTree& windowLayout_, const juce::Identifier& type_, ConnectionPanel& connectionPanel_, GLRenderer& glRenderer)
        : GraphWindow(windowLayout_, type_, connectionPanel_,
                      glRenderer,
                      "Angle (" + degreeSymbol + ")",
                      { "Roll", "Pitch", "Yaw" },
                      { UIColours::graphX, UIColours::graphY, UIColours::graphZ },
                      false)
{
    callbackIDs.push_back(connectionPanel.getConnection()->addQuaternionCallback(quaternionCallback = [&](auto message)
    {
        const auto eulerAngles = Convert::toEulerAngles(message.x, message.y, message.z, message.w);
        update(message.timestamp, { eulerAngles.x, eulerAngles.y, eulerAngles.z });
    }));

    callbackIDs.push_back(connectionPanel.getConnection()->addRotationMatrixCallback(rotationMatrixCallback = [&](auto message)
    {
        const auto quaternion = Convert::toQuaternion(message.xx, message.xy, message.xz,
                                                      message.yx, message.yy, message.yz,
                                                      message.zx, message.zy, message.zz);
        const auto eulerAngles = Convert::toEulerAngles(quaternion.vector.x, quaternion.vector.y, quaternion.vector.z, quaternion.scalar);
        update(message.timestamp, { eulerAngles.x, eulerAngles.y, eulerAngles.z });
    }));

    callbackIDs.push_back(connectionPanel.getConnection()->addEulerAnglesCallback(eulerAnglesCallback = [&](auto message)
    {
        update(message.timestamp, { message.roll, message.pitch, message.yaw });
    }));

    callbackIDs.push_back(connectionPanel.getConnection()->addLinearAccelerationCallback(linearAccelerationCallback = [&](auto message)
    {
        const auto eulerAngles = Convert::toEulerAngles(message.quaternion_x, message.quaternion_y, message.quaternion_z, message.quaternion_w);
        update(message.timestamp, { eulerAngles.x, eulerAngles.y, eulerAngles.z });
    }));

    callbackIDs.push_back(connectionPanel.getConnection()->addEarthAccelerationCallback(earthAccelerationCallback = [&](auto message)
    {
        const auto eulerAngles = Convert::toEulerAngles(message.quaternion_x, message.quaternion_y, message.quaternion_z, message.quaternion_w);
        update(message.timestamp, { eulerAngles.x, eulerAngles.y, eulerAngles.z });
    }));
}

EulerAnglesGraphWindow::~EulerAnglesGraphWindow()
{
    for (const auto callbackID : callbackIDs)
    {
        connectionPanel.getConnection()->removeCallback(callbackID);
    }
}

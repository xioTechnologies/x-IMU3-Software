use crate::command_message::*;
use crate::data_messages::*;
use crate::decode_error::*;
use crate::dispatcher::*;
use crate::statistics::*;

const BUFFER_SIZE: usize = 4096;

pub struct Decoder {
    buffer: [u8; BUFFER_SIZE],
    index: usize,
    pub statistics: Statistics,
    pub dispatcher: Dispatcher,
}

impl Decoder {
    pub fn new() -> Decoder {
        Self {
            buffer: [0; BUFFER_SIZE],
            index: 0,
            statistics: Default::default(),
            dispatcher: Dispatcher::new(),
        }
    }

    pub fn process_bytes(&mut self, bytes: &[u8]) {
        self.statistics.data_total += bytes.len() as u64;

        for byte in bytes {
            self.buffer[self.index] = *byte;

            self.index += 1;
            if self.index >= self.buffer.len() {
                self.statistics.error_total += 1;
                self.dispatcher.sender.send(DispatcherData::DecodeError(DecodeError::BufferOverrun)).ok();
                self.index = 0;
                continue;
            }

            if *byte == b'\n' {
                match self.process_message() {
                    Ok(_) => self.statistics.message_total += 1,
                    Err(decode_error) => {
                        self.statistics.error_total += 1;
                        self.dispatcher.sender.send(DispatcherData::DecodeError(decode_error)).ok();
                    }
                }
                self.index = 0;
            }
        }
    }

    fn process_message(&mut self) -> Result<(), DecodeError> {
        match self.buffer[0] {
            b'{' => self.process_command_message(),
            _ => self.process_data_message(),
        }
    }

    fn process_command_message(&self) -> Result<(), DecodeError> {
        let command = CommandMessage::parse_bytes(&self.buffer[..self.index])?;
        self.dispatcher.sender.send(DispatcherData::Command(command)).ok();
        Ok(())
    }

    fn process_data_message(&mut self) -> Result<(), DecodeError> {
        let message = Self::undo_byte_stuffing(&mut self.buffer[..self.index])?;

        macro_rules! parse {
            ($data_message:ident, $dispatcher_data:ident) => {{
                match $data_message::parse(message) {
                    Ok(message) => {
                        self.dispatcher.sender.send(DispatcherData::$dispatcher_data(message)).ok();
                        return Ok(());
                    }
                    Err(DecodeError::InvalidMessageIdentifier) => {}
                    Err(error) => return Err(error),
                }
            }};
        }

        // Start of code block #0 generated by x-IMU3-API/Rust/src/data_messages/generate_data_messages.py
        parse!(InertialMessage, Inertial);
        parse!(MagnetometerMessage, Magnetometer);
        parse!(QuaternionMessage, Quaternion);
        parse!(RotationMatrixMessage, RotationMatrix);
        parse!(EulerAnglesMessage, EulerAngles);
        parse!(LinearAccelerationMessage, LinearAcceleration);
        parse!(EarthAccelerationMessage, EarthAcceleration);
        parse!(AhrsStatusMessage, AhrsStatus);
        parse!(HighGAccelerometerMessage, HighGAccelerometer);
        parse!(TemperatureMessage, Temperature);
        parse!(BatteryMessage, Battery);
        parse!(RssiMessage, Rssi);
        parse!(SerialAccessoryMessage, SerialAccessory);
        parse!(NotificationMessage, Notification);
        parse!(ErrorMessage, Error);
        // End of code block #0 generated by x-IMU3-API/Rust/src/data_messages/generate_data_messages.py

        Err(DecodeError::InvalidMessageIdentifier)
    }

    fn undo_byte_stuffing(message: &mut [u8]) -> Result<&[u8], DecodeError> {
        const BYTE_STUFFING_END: u8 = 0x0A;
        const BYTE_STUFFING_ESC: u8 = 0xDB;
        const BYTE_STUFFING_ESC_END: u8 = 0xDC;
        const BYTE_STUFFING_ESC_ESC: u8 = 0xDD;

        let mut source_index = 0;
        let mut destination_index = 0;

        while source_index < message.len() {
            if message[source_index] == BYTE_STUFFING_ESC {
                source_index += 1;

                if source_index >= message.len() {
                    return Err(DecodeError::InvalidEscapeSequence);
                }

                match message[source_index] {
                    BYTE_STUFFING_ESC_END => message[destination_index] = BYTE_STUFFING_END,
                    BYTE_STUFFING_ESC_ESC => message[destination_index] = BYTE_STUFFING_ESC,
                    _ => return Err(DecodeError::InvalidEscapeSequence),
                }
            } else {
                message[destination_index] = message[source_index];
            }
            source_index += 1;
            destination_index += 1;
        }
        Ok(&message[..destination_index])
    }
}

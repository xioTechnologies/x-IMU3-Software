use crate::data_messages::*;
use crate::decode_error::*;
use libc::size_t;
use std::fmt;
use std::mem::size_of;
use std::os::raw::c_char;

#[repr(C)]
#[derive(Clone, Copy)]
pub struct $name_pascal_case$Message {
    pub timestamp: u64,
    pub char_array: [c_char; DATA_MESSAGE_CHAR_ARRAY_SIZE],
    pub number_of_bytes: size_t,
}

impl $name_pascal_case$Message {
    pub fn char_array_as_string(self) -> String {
        char_array_to_string(&self.char_array, self.number_of_bytes)
    }
}

impl DataMessage for $name_pascal_case$Message {
    fn get_ascii_id() -> u8 {
        b'$ascii_id$'
    }

    fn parse_ascii(message: &str) -> Result<Self, DecodeError> {
        match scan_fmt!(message, "{},{d},{[^\n]}\n", char, u64, String) {
            Ok((_, timestamp, string)) => {
                let (char_array, number_of_bytes) = string_to_char_array(string);

                Ok($name_pascal_case$Message {
                    timestamp,
                    char_array,
                    number_of_bytes,
                })
            }
            Err(_) => Err(DecodeError::UnableToParseAsciiMessage),
        }
    }

    fn parse_binary(message: &[u8]) -> Result<Self, DecodeError> {
        #[repr(C, packed)]
        struct Header {
            _id: u8,
            timestamp: u64,
        }

        let min_message_size = size_of::<Header>() + 1; // include termination byte

        if message.len() < min_message_size {
            return Err(DecodeError::InvalidBinaryMessageLength);
        }

        let timestamp = unsafe {
            let ref binary_message = *(message.as_ptr() as *const Header);
            binary_message.timestamp
        };

        let (char_array, number_of_bytes) = slice_to_char_array(&message[size_of::<Header>()..(message.len() - 1)]); // exclude termination byte

        Ok($name_pascal_case$Message {
            timestamp,
            char_array,
            number_of_bytes,
        })
    }

    fn get_csv_file_name(&self) -> &'static str {
        "$name_pascal_case$.csv"
    }

    fn get_csv_headings(&self) -> &'static str {
        "Timestamp (us),String\n"
    }

    fn to_csv_row(&self) -> String {
        format!("{},{}\n", self.timestamp, char_array_to_string(&self.char_array, self.number_of_bytes))
    }
}

impl fmt::Display for $name_pascal_case$Message {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "{:>8} us \"{}\"", self.timestamp, char_array_to_string(&self.char_array, self.number_of_bytes))
    }
}

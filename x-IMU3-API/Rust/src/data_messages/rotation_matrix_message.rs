// This file was generated by x-IMU3-API/Rust/src/data_messages/generate_data_messages.py

use std::fmt;
use std::mem::size_of;
use crate::data_messages::*;
use crate::decode_error::*;

#[repr(C)]
#[derive(Clone, Copy)]
pub struct RotationMatrixMessage {
    pub timestamp: u64,
    pub xx_element: f32,
    pub xy_element: f32,
    pub xz_element: f32,
    pub yx_element: f32,
    pub yy_element: f32,
    pub yz_element: f32,
    pub zx_element: f32,
    pub zy_element: f32,
    pub zz_element: f32,
}

impl DataMessage for RotationMatrixMessage {
    fn get_ascii_id() -> u8 {
        'R' as u8
    }

    fn parse_ascii(message: &str) -> Result<Self, DecodeError> {
        match scan_fmt!( message, "{},{d},{f},{f},{f},{f},{f},{f},{f},{f},{f}\r\n",  char, u64, f32, f32, f32, f32, f32, f32, f32, f32, f32) {
            Ok((_, timestamp, xx_element, xy_element, xz_element, yx_element, yy_element, yz_element, zx_element, zy_element, zz_element)) => Ok(RotationMatrixMessage { timestamp, xx_element, xy_element, xz_element, yx_element, yy_element, yz_element, zx_element, zy_element, zz_element }),
            Err(_) => Err(DecodeError::UnableToParseAsciiMessage),
        }
    }

    fn parse_binary(message: &[u8]) -> Result<Self, DecodeError> {
        #[repr(C, packed)]
        struct BinaryMessage {
            id: u8,
            timestamp: u64,
            xx_element: f32,
            xy_element: f32,
            xz_element: f32,
            yx_element: f32,
            yy_element: f32,
            yz_element: f32,
            zx_element: f32,
            zy_element: f32,
            zz_element: f32,
            termination: u8,
        }

        if message.len() != size_of::<BinaryMessage>() {
            return Err(DecodeError::InvalidBinaryMessageLength);
        }

        let binary_message = unsafe {
            let ref binary_message = *(message.as_ptr() as *const BinaryMessage);
            binary_message
        };

        Ok(RotationMatrixMessage { timestamp: binary_message.timestamp, xx_element: binary_message.xx_element, xy_element: binary_message.xy_element, xz_element: binary_message.xz_element, yx_element: binary_message.yx_element, yy_element: binary_message.yy_element, yz_element: binary_message.yz_element, zx_element: binary_message.zx_element, zy_element: binary_message.zy_element, zz_element: binary_message.zz_element })
    }

    fn get_csv_file_name(&self) -> &'static str {
        "RotationMatrix.csv"
    }

    fn get_csv_headings(&self) -> &'static str {
        "Timestamp (us),XX Element,XY Element,XZ Element,YX Element,YY Element,YZ Element,ZX Element,ZY Element,ZZ Element\n"
    }

    fn to_csv_row(&self) -> String {
        format!("{},{:.6},{:.6},{:.6},{:.6},{:.6},{:.6},{:.6},{:.6},{:.6}\n", self.timestamp, self.xx_element, self.xy_element, self.xz_element, self.yx_element, self.yy_element, self.yz_element, self.zx_element, self.zy_element, self.zz_element)
    }
}

impl fmt::Display for RotationMatrixMessage {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "{:>8} us {:>8.3} {:>8.3} {:>8.3} {:>8.3} {:>8.3} {:>8.3} {:>8.3} {:>8.3} {:>8.3}", self.timestamp, self.xx_element, self.xy_element, self.xz_element, self.yx_element, self.yy_element, self.yz_element, self.zx_element, self.zy_element, self.zz_element)
    }
}
